<patch-1.0 appVersion="1.0.12">
   <obj type="audio/outconfig" uuid="eace67e3304afaa1bb695b444e9345f2d8adaf00" name="outconfig_1" x="1302" y="0">
      <params/>
      <attribs>
         <combo attributeName="headphones" selection="-18dB"/>
         <combo attributeName="mode" selection="Stereo"/>
      </attribs>
   </obj>
   <obj type="audio/inconfig" uuid="9a80ef3c19f2a8f81da3a3b7c1c44d18126b97d9" name="inconfig_1" x="28" y="14">
      <params/>
      <attribs>
         <combo attributeName="gain" selection="-3dB"/>
         <combo attributeName="boost" selection="20dB"/>
         <combo attributeName="mode" selection="Mono(L)"/>
      </attribs>
   </obj>
   <obj type="gpio/in/digital" uuid="f59f139e8da912742832dc541157f20f30b7ac1b" name="digital_1" x="126" y="14">
      <params/>
      <attribs>
         <combo attributeName="pad" selection="PB0"/>
         <combo attributeName="mode" selection="pullup"/>
      </attribs>
   </obj>
   <obj type="logic/toggle" uuid="f42f0d3aab552c17bc78b9e65f85dc24f977503d" name="toggle_1" x="224" y="14">
      <params/>
      <attribs/>
   </obj>
   <obj type="gpio/out/led2" uuid="3d7a4c75d1f9901181a17ba5de752782de911803" name="led2_1" x="294" y="14">
      <params/>
      <attribs/>
   </obj>
   <obj type="gpio/in/digital" uuid="f59f139e8da912742832dc541157f20f30b7ac1b" name="digital_2" x="392" y="14">
      <params/>
      <attribs>
         <combo attributeName="pad" selection="PB1"/>
         <combo attributeName="mode" selection="pullup"/>
      </attribs>
   </obj>
   <patchobj type="patch/object" uuid="5b7c124c-4176-4250-97f1-d00a76b02a60" name="toggle_2" x="504" y="14">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="5b7c124c-4176-4250-97f1-d00a76b02a60">
         <sDescription>toggle</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>logic.axh</helpPatch>
         <inlets>
            <bool32.rising name="trig" description="trigger"/>
         </inlets>
         <outlets>
            <bool32 name="o" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[   int ntrig;
   int op;
]]></code.declaration>
         <code.init><![CDATA[ntrig = 0;
op = 1;]]></code.init>
         <code.krate><![CDATA[if ((inlet_trig>0) && !ntrig) {op = !op; ntrig=1;}
if (!(inlet_trig>0)) ntrig=0;
outlet_o= op;
]]></code.krate>
      </object>
   </patchobj>
   <obj type="gpio/out/led1" uuid="c6679540460d64e2e71760e61cb82fac227e2764" name="led1_1" x="644" y="14">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/in left" uuid="d40e60b7641fe75af4d7c91b45bb038aacafc52e" name="in_1" x="0" y="98">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="c089863e-a202-47fd-8e91-690be549a54d" name="gain_1" x="84" y="98">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="c089863e-a202-47fd-8e91-690be549a54d">
         <sDescription>on/off switch</sDescription>
         <author>Juergen Schwietering</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <frac32buffer name="in"/>
            <bool32 name="onoff"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="output"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[if (inlet_onoff)
	outlet_out = inlet_in;
else
	outlet_out = 0;]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="5a1adc95-6044-41b4-86c3-e9e98cec1f1d" name="mix_1" x="182" y="98">
      <params>
         <frac32.u.map name="gain1" value="64.0"/>
         <frac32.u.map name="gain2" value="25.0"/>
         <frac32.u.map name="gain3" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="5a1adc95-6044-41b4-86c3-e9e98cec1f1d">
         <sDescription>3 input s-rate mixer, shows gain units</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <inlets>
            <frac32buffer name="in1" description="input 1"/>
            <frac32buffer name="in2" description="input 2"/>
            <frac32buffer name="in3" description="input 3"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="mix out"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map.gain name="gain1">
               <DefaultValue v="32.0"/>
            </frac32.u.map.gain>
            <frac32.u.map.gain name="gain2">
               <DefaultValue v="32.0"/>
            </frac32.u.map.gain>
            <frac32.u.map.gain name="gain3">
               <DefaultValue v="32.0"/>
            </frac32.u.map.gain>
         </params>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[int32_t accum = ___SMMUL(inlet_in1,param_gain1);
accum = ___SMMLA(inlet_in2,param_gain2,accum);
accum = ___SMMLA(inlet_in3,param_gain3,accum);
outlet_out=  __SSAT((accum<<1),28);]]></code.srate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="c39fa438-4480-45cf-b6db-06dd3173bfd6" name="echo_1" x="308" y="98">
      <params/>
      <attribs>
         <spinner attributeName="maxDelayInSeconds" value="20"/>
      </attribs>
      <object id="patch/object" uuid="c39fa438-4480-45cf-b6db-06dd3173bfd6">
         <sDescription>Multitap delay output for sequence style effects</sDescription>
         <author>Juergen Schwietering</author>
         <license>BSD</license>
         <helpPatch>delay.axh</helpPatch>
         <inlets>
            <frac32buffer name="in" description="input"/>
            <int32 name="delayTimeInSamples"/>
            <int32 name="tap1InSamples"/>
            <int32 name="tap2InSamples"/>
            <int32 name="tap3InSamples"/>
            <int32 name="tap4InSamples"/>
            <bool32 name="samplehold"/>
         </inlets>
         <outlets>
            <frac32buffer name="tap0" description="direct output"/>
            <frac32buffer name="tap1"/>
            <frac32buffer name="tap2"/>
            <frac32buffer name="tap3"/>
            <frac32buffer name="loopend" description="final"/>
            <int32 name="db1"/>
            <int32 name="db2"/>
            <int32 name="db3"/>
            <int32 name="db4"/>
            <int32 name="dbLast"/>
            <int32 name="dbIn"/>
            <bool32 name="loopstart"/>
         </outlets>
         <displays/>
         <params/>
         <attribs>
            <spinner name="maxDelayInSeconds" MinValue="1" MaxValue="60" DefaultValue="20"/>
         </attribs>
         <includes/>
         <code.declaration><![CDATA[uint32_t head;
int16_t *delayline;
int32_t tapsInSamples[4];

int32_t attackTime = 5;
int32_t releaseTime = 50;
int32_t attack = float_to_q27(exp (-1.0 / (attackTime * 48000 / 1000.0)));
int32_t release = float_to_q27(exp (-1.0 / (releaseTime * 48000 / 1000.0)));

struct DBLevels
{
	int32_t level;
	int32_t db;
	
	void step(int32_t val, int32_t attack, int32_t release)
	{
		auto s = val;
		if (s < 0)
			s = -s;
		if (s > level)
		{
			level = s - (___SMMUL(attack, s - level)>>5);
		}
		else
		{
			level = s + (___SMMUL(release, level-s)>>5);
		}
	}
} dbLevels[6];]]></code.declaration>
         <code.init><![CDATA[static int16_t _delay[attr_maxDelayInSeconds*48000] __attribute__ ((section (".sdram")));
delayline = &_delay[0];

for (auto i=0; i < sizeof(_delay); ++i)
{
   delayline[i] = 0;
}
head = 0;]]></code.init>
         <code.krate><![CDATA[int32_t _totalTapDelay = inlet_delayTimeInSamples;

tapsInSamples[0] = inlet_tap1InSamples;
tapsInSamples[1] = inlet_tap2InSamples;
tapsInSamples[2] = inlet_tap3InSamples;
tapsInSamples[3] = inlet_tap4InSamples;

static int32_t processCnt = 0;
outlet_db1 = dbLevels[0].db;
outlet_db2 = dbLevels[1].db;
outlet_db3 = dbLevels[2].db;
outlet_db4 = dbLevels[3].db;
outlet_dbLast = dbLevels[4].db;
outlet_dbIn = dbLevels[5].db;

if (--processCnt < 0)
{
	processCnt = 60;
	for (int i=0; i < 6; ++i)
	{
		dbLevels[i].db = static_cast<int>(log(q27_to_float(dbLevels[i].level))/log(2.0f)*6.0f);
	}
}

if (head < 2400)
{
	if (head < 16)
	{
		LogTextMessage("darn");
	}
	outlet_loopstart = 1;
}
else {
	outlet_loopstart = 0;
}]]></code.krate>
         <code.srate><![CDATA[int32_t vals[4];

#define BITRES 13

outlet_loopend = delayline[head] << BITRES;
if (!inlet_samplehold)
{
	__SSAT(inlet_in, 28);
	delayline[head] = inlet_in >> BITRES;
}

for (auto i=0; i < 4; ++i)
{
    int32_t rdPos = head-tapsInSamples[i];
    if (rdPos < 0)
        rdPos += _totalTapDelay;
    vals[i] = delayline[rdPos]<<BITRES;
}
head++;
if (head >= _totalTapDelay) 
{
     head = 0;
}


dbLevels[0].step(vals[0], attack, release);
dbLevels[1].step(vals[1], attack, release);
dbLevels[2].step(vals[2], attack, release);
dbLevels[3].step(vals[3], attack, release);
dbLevels[4].step(outlet_loopend, attack, release);
dbLevels[5].step(inlet_in, attack, release);

outlet_tap0 = vals[0];
outlet_tap1 = vals[1];
outlet_tap2 = vals[2];
outlet_tap3 = vals[3];]]></code.srate>
      </object>
   </patchobj>
   <obj type="trisfreq" uuid="c9377000-383f-43c6-b11c-406b2ee95f2a" name="trisfreq_1" x="868" y="126">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="cdc04a58-47fe-43db-9cc5-1f709b77c42e" name="mix_2" x="1008" y="126">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="cdc04a58-47fe-43db-9cc5-1f709b77c42e">
         <sDescription>4 input</sDescription>
         <author>JS</author>
         <license>BSD</license>
         <inlets>
            <frac32buffer name="in1" description="input 1"/>
            <frac32buffer name="in2" description="input 2"/>
            <frac32buffer name="in3" description="input 3"/>
            <frac32buffer name="in4" description="input 4"/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="mix out"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.srate><![CDATA[outlet_out = inlet_in1+inlet_in2+inlet_in3+inlet_in4;]]></code.srate>
      </object>
   </patchobj>
   <obj type="filter/lp1" uuid="1b1fd7085e44d2b7b80b59b8d68796b909c1b2cc" name="lp1_1" x="1092" y="126">
      <params>
         <frac32.s.map name="freq" value="50.0"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="df57353c-5d94-4bd3-83b3-abc9b92a1826" name="mix_3" x="1204" y="126">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="df57353c-5d94-4bd3-83b3-abc9b92a1826">
         <sDescription>2 input s-rate mixer, shows gain units</sDescription>
         <author>JS</author>
         <license>BSD</license>
         <inlets>
            <frac32buffer name="in1" description="input 1"/>
            <frac32buffer name="in2" description="input 2"/>
            <frac32 name="mix" description="mix value "/>
         </inlets>
         <outlets>
            <frac32buffer name="out" description="mix out"/>
         </outlets>
         <displays>
            <int32.label name="mix"/>
         </displays>
         <params/>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[disp_mix = inlet_mix;]]></code.krate>
         <code.srate><![CDATA[outlet_out = (___SMMUL(inlet_in2<<2, inlet_mix<<3)) +
(___SMMUL(inlet_in1<<2, ((1<<27)-inlet_mix)<<3));]]></code.srate>
      </object>
   </patchobj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_1" x="1288" y="126">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="251c57d1-6833-4666-a469-fb7c2b44e6c9" name="midihandler" x="560" y="182">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="251c57d1-6833-4666-a469-fb7c2b44e6c9">
         <author>JS</author>
         <license>BSD</license>
         <inlets>
            <int32 name="level1"/>
            <int32 name="level2"/>
            <int32 name="level3"/>
            <int32 name="level4"/>
            <int32 name="levelmain"/>
            <int32 name="patchnr"/>
            <bool32 name="save"/>
            <bool32 name="load"/>
         </inlets>
         <outlets>
            <frac32 name="pitch1"/>
            <frac32 name="combfdbk1"/>
            <frac32 name="comblevel1"/>
            <frac32 name="ringlevel1"/>
            <frac32 name="vcflevel1"/>
            <frac32 name="level1"/>
            <frac32 name="pitch2"/>
            <frac32 name="combfdbk2"/>
            <frac32 name="comblevel2"/>
            <frac32 name="ringlevel2"/>
            <frac32 name="vcflevel2"/>
            <frac32 name="level2"/>
            <frac32 name="pitch3"/>
            <frac32 name="combfdbk3"/>
            <frac32 name="comblevel3"/>
            <frac32 name="ringlevel3"/>
            <frac32 name="vcflevel3"/>
            <frac32 name="level3"/>
            <frac32 name="pitch4"/>
            <frac32 name="combfdbk4"/>
            <frac32 name="comblevel4"/>
            <frac32 name="ringlevel4"/>
            <frac32 name="vcflevel4"/>
            <frac32 name="level4"/>
            <frac32 name="mix"/>
         </outlets>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int count = 0;
int initialize = 0;
//int lastValue[128];
int queueHead = 0;
int queueTail = 0;
int inQueue = 0;
uint8_t midiQueue[1024];
const int32_t gainValues[4] = {float_to_q27(0.0),float_to_q27(0.25),float_to_q27(0.5),float_to_q27(0.999)}; 

int32_t lastLevel[5] = {0,0,0,0,0};

struct Settings
{
	int8_t combGain[4]; // logic level (off, 1, 2, 3=max)
	int32_t combGainValue[4]; // dsp level 
	int8_t ringGain[4];
	int32_t ringGainValue[4];
	int8_t vcfGain[4];
	int32_t vcfGainValue[4];
	int32_t outGain[4];
	int32_t pitchValue[4];
	int32_t combFeedbackLevel;
	int32_t mixLevel;
} settings = {
	{3,3,3,3},
	{float_to_q27(0.999), float_to_q27(0.999), float_to_q27(0.999), float_to_q27(0.999)},
	{2,2,2,2},
	{float_to_q27(0.75), float_to_q27(0.75), float_to_q27(0.75), float_to_q27(0.75)},
	{0,0,0,0},
	{float_to_q27(0.0),float_to_q27(0.0),float_to_q27(0.0),float_to_q27(0.0)},
	{float_to_q27(0.999),float_to_q27(0.999),float_to_q27(0.999),float_to_q27(0.999)},
	{(-12)<<21,0<<21, 7 << 21, 12<<21},
	float_to_q27(0.0),
	float_to_q27(0.5)};

int programmingTone = -1;


void saveDataBlock(FIL &file, const void *data, int size, char *filename)
{
    FRESULT err;
    UINT bytes_written;
    err = f_write(&file, data, size,&bytes_written);
    if (err != FR_OK) report_fatfs_error(err,filename);
}

void loadDataBlock(FIL &file, void *data, int size, char *filename)
{
    FRESULT err;
    UINT bytes_read;
    err = f_read(&file, data, size,&bytes_read);
    if (err != FR_OK) report_fatfs_error(err,filename);
}
void savePatch(int nr)
{
    char filename[128];
    chsnprintf(filename, sizeof(filename), "patch_%03d.bin", nr); 
    LogTextMessage("saving to %s", filename);
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    codec_clearbuffer();
    err = f_open(&FileObject, filename, FA_WRITE | FA_CREATE_ALWAYS);
    if (err != FR_OK) {report_fatfs_error(err,filename); return;}
    saveDataBlock(FileObject, (void *)&settings, sizeof(settings),filename);
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,filename);
}

void loadPatch(int nr)
{
    char filename[128];
    chsnprintf(filename, sizeof(filename), "patch_%03d.bin", nr); 
    LogTextMessage("saving to %s", filename);
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    codec_clearbuffer();
    err = f_open(&FileObject, filename, FA_READ | FA_OPEN_EXISTING);
    if (err != FR_OK) {report_fatfs_error(err,filename); return;}
    loadDataBlock(FileObject,  (void *)&settings, sizeof(settings),filename);
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,filename);	
    setStatus();
}

const int cursorKeyIndex = 40;
const int sceneKeyIndex = 48;
const int cursorKeysNote = 64;
const int sceneKeysNote = 82;


/*
 * return 0 for off
 * 1 for first level
 * 5 for second level
 * 3 for highest level
 */
int ledLevel(int32_t value, int32_t limit1=float_to_q27(0.5), int32_t limit2=float_to_q27(0.75))
{
	if (value==0)
		return 0;
	if (value <= limit1)
		return 1;
	if (value <= limit2)
		return 5;
	return 3;	
}

int levelMap[4] = {0,1,5,3};

void setStatus()
{
	for (int c=0; c < 4; ++c)
	{
		setMatrixChannelValue(c,0,levelMap[settings.combGain[c]]);
		setMatrixChannelValue(c,1,levelMap[settings.ringGain[c]]);
		setMatrixChannelValue(c,2,levelMap[settings.vcfGain[c]]);
	}
}

void setButtonKey(uint8_t index, uint8_t value)
{
	AddMidiMessage(MIDI_NOTE_ON, index, value); 
}

void resetAll(uint8_t value)
{
	for (auto i=0; i < 40; ++i)
	{
		setButtonKey(i, value);
	}
	for (auto i=0; i < 8; ++i)
	{
		setButtonKey(cursorKeysNote+i, value);
	}
	for (auto i=0; i < 6; ++i)
	{
		setButtonKey(sceneKeysNote+i, value);
	}
}

void feedQueue(uint8_t value)
{
	inQueue++;
	midiQueue[queueHead++] = value;
	if (queueHead >= sizeof(midiQueue)/sizeof(midiQueue[0]))
		queueHead = 0;	
}

int countFood() 
{
	return inQueue;
}

uint8_t eatQueue()
{
	auto value = midiQueue[queueTail++];
	if (queueTail >= sizeof(midiQueue)/sizeof(midiQueue[0]))
		queueTail = 0;	
	inQueue--;
	return value;
}

void AddMidiMessage(uint8_t status, uint8_t data1, uint8_t data2)
{
	feedQueue(status);
	feedQueue(data1);
	feedQueue(data2);
}


const int8_t smallNumberFont[20] = {31, 31, 0,  31, 23, 29, 21, 31, 28, 15,
                                    29, 23, 31, 23, 16, 31, 21, 21, 29, 31};

const int8_t digitsAndLetter[41 * 3] = {
    31, 17, 31, 0,  31, 0,  23, 21, 29, 21, 21, 31, 28, 4,  15, 29, 21, 23,
    31, 21, 23, 16, 16, 31, 31, 21, 31, 28, 20, 31, 31, 20, 31, 31, 21, 27,
    31, 17, 17, 31, 17, 14, 31, 21, 21, 31, 20, 16, 31, 17, 23, 31, 4,  31,
    0,  31, 0,  3,  1,  31, 31, 4,  27, 31, 1,  1,  31, 8,  31, 15, 4,  30,
    31, 17, 31, 31, 20, 28, 30, 18, 31, 31, 20, 11, 29, 21, 23, 16, 31, 16,
    31, 1,  31, 30, 1,  30, 31, 2,  31, 27, 4,  27, 24, 7,  24, 19, 21, 25, // Z
    0,  29, 0,                                                              // !
    4,  31, 4,                                                              // +
    4,  4,  4,                                                              // -
    31, 5,  6,                                                              // b
    31, 10, 31,                                                             //#
};

uint8_t currentMatrix[5][8];
uint8_t newMatrix[5][8];

void clearAll(int value)
{
  for (int x = 0; x < 8; ++x) {
    for (int y = 0; y < 5; ++y) {
    	currentMatrix[y][x] = value-1;
    	newMatrix[y][x] = value;
    }
  }
	
}

void renderNewMatrix() {
  for (int x = 0; x < 8; ++x) {
    for (int y = 0; y < 5; ++y) {
      if (newMatrix[y][x] != currentMatrix[y][x]) {
      	//LogTextMessage("pos %d, value %d", x + y * 8, newMatrix[y][x]);
      	AddMidiMessage(0x90, x + y * 8, newMatrix[y][x]); 
          currentMatrix[y][x] = newMatrix[y][x];
      }
    }
  }
}

void setMatrixColumn(int x, int value, int8_t color) {
  if (x >= 8)
    return;
  for (int y = 0; y < 5; ++y) 
  {
    if ((value & 0x01) == 1) 
      newMatrix[y][x] = color;
    else
      newMatrix[y][x] = 0;
    value >>= 1;
  }
}

void setMatrixChannelValue(int c, int paramY, int8_t color) {
  if (c >= 4)
    return;
  newMatrix[paramY][c*2] = color;
}

void setText(int8_t x, char value, int8_t color=1) {
  int index = -1;
  if ((value >= '0') && (value <= '9'))
    index = (value - '0') * 3;
  if ((value >= 'A') && (value <= 'Z'))
    index = (value - 'A' + 10) * 3;
  if ((value >= 'a') && (value <= 'z'))
    index = (value - 'a' + 10) * 3;
  if (index >= 0) {
    setMatrixColumn(x++, digitsAndLetter[index++], color);
    setMatrixColumn(x++, digitsAndLetter[index++], color);
    setMatrixColumn(x++, digitsAndLetter[index++], color);
    setMatrixColumn(x, 0, color);
  }
}

void setSmallNumber(int8_t x, int value, int8_t color=1) {
  setMatrixColumn(x++, smallNumberFont[value * 2], color);
  setMatrixColumn(x++, smallNumberFont[value * 2 + 1], color);
  setMatrixColumn(x, 0, color);
}

void updateLevel(int channel, int32_t level)
{
	int idx;
	if (channel == 4)
		idx = 0;
	else
		idx = channel*2+1;

	if (level >-20)
		newMatrix[4][idx] = 3;
	else if (level > -30)
		newMatrix[4][idx] = 5;
	else	if (level > -50)
		newMatrix[4][idx] = 1;
	else	newMatrix[4][idx] = 0;
}


void setTrisValue(int row, int channel)
{
	switch(row)
	{
		case 0:settings.combGain[channel]++; 
			if (settings.combGain[channel] >=4)
				settings.combGain[channel] = 0;
			settings.combGainValue[channel] = gainValues[settings.combGain[channel]];
			LogTextMessage("Gain comb %d %d", channel, settings.combGainValue[channel]);
			break;
		case 1:settings.ringGain[channel]++; 
			if (settings.ringGain[channel] >=4)
				settings.ringGain[channel] = 0;
			settings.ringGainValue[channel] = gainValues[settings.ringGain[channel]];
			LogTextMessage("Gain ring %d %d", channel, settings.ringGainValue[channel]);
			break;
		case 2:settings.vcfGain[channel]++; 
			if (settings.vcfGain[channel] >=4)
				settings.vcfGain[channel] = 0;
			settings.vcfGainValue[channel] = gainValues[settings.vcfGain[channel]];
			LogTextMessage("Gain vcf %d %d", channel, settings.vcfGainValue[channel]);
			break;
	}
	setStatus();
}

void ProgramNote(int height, int velo)
{
	if (programmingTone >= 0)
	{
		settings.pitchValue[programmingTone] = (height - 64) << 21;
		setProgrammingTone(programmingTone);
	}
}

void setProgrammingTone(int channel)
{
	if (programmingTone == -1)
	{
		AddMidiMessage(0x90, cursorKeysNote+channel*2,2);
		AddMidiMessage(0x90, cursorKeysNote+channel*2+1,2);
		programmingTone = channel;
	}
	else
	{
		AddMidiMessage(0x90, cursorKeysNote+channel*2,0);
		AddMidiMessage(0x90, cursorKeysNote+channel*2+1,0);
		programmingTone = -1;	
	}
}

void SetVolumeLevel(int channel, int level)
{
	settings.outGain[channel] = float_to_q27((float)level/128.0);
	//LogTextMessage("%d", outGain[channel]);
}

void SetCombFeedBack(int level)
{
	const float c_maxTime = 0.5f;
	settings.combFeedbackLevel = float_to_q27((level-64)/128.0f*c_maxTime);
}

void SetMix(int level)
{
     settings.mixLevel = float_to_q27(level/128.0f);
}]]></code.declaration>
         <code.init><![CDATA[SetCombFeedBack(65);
clearAll(0);
setStatus();]]></code.init>
         <code.krate><![CDATA[static int countUp=0;
static int beat = 3000;

if (inlet_save)
{
	LogTextMessage("should save patch: %d", inlet_patchnr);
	savePatch(inlet_patchnr);
}
if (inlet_load)
{
	LogTextMessage("should load patch: %d", inlet_patchnr);
	loadPatch(inlet_patchnr);
}

outlet_pitch1=settings.pitchValue[0];
outlet_pitch2=settings.pitchValue[1];
outlet_pitch3=settings.pitchValue[2];
outlet_pitch4=settings.pitchValue[3];
outlet_comblevel1=settings.combGainValue[0];
outlet_comblevel2=settings.combGainValue[1];
outlet_comblevel3=settings.combGainValue[2];
outlet_comblevel4=settings.combGainValue[3];
outlet_combfdbk1=settings.combFeedbackLevel;
outlet_combfdbk2=settings.combFeedbackLevel;
outlet_combfdbk3=settings.combFeedbackLevel;
outlet_combfdbk4=settings.combFeedbackLevel;
outlet_ringlevel1=settings.ringGainValue[0];
outlet_ringlevel2=settings.ringGainValue[1];
outlet_ringlevel3=settings.ringGainValue[2];
outlet_ringlevel4=settings.ringGainValue[3];
outlet_vcflevel1=settings.vcfGainValue[0];
outlet_vcflevel2=settings.vcfGainValue[1];
outlet_vcflevel3=settings.vcfGainValue[2];
outlet_vcflevel4=settings.vcfGainValue[3];
outlet_level1=settings.outGain[0];
outlet_level2=settings.outGain[1];
outlet_level3=settings.outGain[2];
outlet_level4=settings.outGain[3];

outlet_mix=settings.mixLevel;

beat--;
if (beat <=0)
{
	renderNewMatrix();
	beat = 100;

	if (inlet_levelmain != lastLevel[4])
	{
		updateLevel(4, inlet_levelmain);
		lastLevel[4] = inlet_levelmain;
	}
	if (inlet_level1 != lastLevel[0])
	{
		updateLevel(0, inlet_level1);
		lastLevel[0] = inlet_level1;
	}
	if (inlet_level2 != lastLevel[1])
	{
		updateLevel(1, inlet_level2);
		lastLevel[1] = inlet_level2;
	}
	if (inlet_level3 != lastLevel[2])
	{
		updateLevel(2, inlet_level3);
		lastLevel[2] = inlet_level3;
	}
	if (inlet_level4 != lastLevel[3])
	{
		updateLevel(3, inlet_level4);
		lastLevel[3] = inlet_level4;
	}
}

auto foodCnt = countFood();

if (foodCnt)
{
	auto len = MidiGetOutputBufferAvailable(MIDI_DEVICE_USB_HOST);
	//LogTextMessage("food: %d, midilen %d", countFood(), len);
	if (len >= 3)
	{
		auto status = eatQueue();
		uint8_t value2, value3;
		switch(status & 0xF0)
		{
			case 0x80:
			case 0x90:
			case 0xA0:
			case 0xB0:
			case 0xE0:
				value2 = eatQueue();
				value3 = eatQueue();
				MidiSend3(MIDI_DEVICE_USB_HOST, 1, status, value2, value3); 
				break;
			case 0xC0:
			case 0xD0:
				value2 = eatQueue();
				MidiSend2(MIDI_DEVICE_USB_HOST, 1, status, value2); 
				break;
			
		}
	}
}]]></code.krate>
         <code.midihandler><![CDATA[if (status == (MIDI_NOTE_ON | 1))
{
	ProgramNote(data1, data2);
}

if (status == (MIDI_NOTE_OFF | 1))
{
}

if ((status == MIDI_NOTE_ON) || (status == MIDI_NOTE_OFF))
{
	if (data1 < 55)
	{
		int channel = (data1/2)%4;
		int row = data1/8;
		if ((data1 %2) == 0)
		{
			if (status == MIDI_NOTE_ON)
				setTrisValue(row, channel);
		}
		else
		{
			if (data1/8 == 0)
			{
				if (status == MIDI_NOTE_ON)
					setProgrammingTone(data1/2);
			}
		}
		
	}else if (data1 >= 64 && data1 <= 71)
	{
	}
}


if (status == MIDI_CONTROL_CHANGE)
{
	if ((data1>=48 && data1<=51))
	{
		SetVolumeLevel(data1-48, data2);		
	}
	if (data1==52)
	{
		SetCombFeedBack(data2);
	}
	if (data1==55)
	{
		SetMix(data2);
	}
}]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="8e65e2a2-a2ed-4ebc-8fc0-631a8cf64753" name="kticks2sec_1" x="14" y="196">
      <params>
         <int32 name="bpm" value="110"/>
         <int32 name="div" value="2"/>
         <int32 name="total" value="8"/>
         <int32 name="tap1" value="2"/>
         <int32 name="tap2" value="3"/>
         <int32 name="tap3" value="5"/>
         <int32 name="tap4" value="7"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="8e65e2a2-a2ed-4ebc-8fc0-631a8cf64753">
         <sDescription>BPM to samples</sDescription>
         <author>JS</author>
         <license>GPL</license>
         <inlets>
            <int32 name="patchnr"/>
            <bool32 name="save"/>
            <bool32 name="load"/>
         </inlets>
         <outlets>
            <int32 name="samplesTotal"/>
            <int32 name="tap1"/>
            <int32 name="tap2"/>
            <int32 name="tap3"/>
            <int32 name="tap4"/>
         </outlets>
         <displays>
            <int32.label name="d1"/>
            <int32.label name="d2"/>
         </displays>
         <params>
            <int32 name="bpm">
               <MinValue i="40"/>
               <MaxValue i="240"/>
            </int32>
            <int32 name="div">
               <MinValue i="1"/>
               <MaxValue i="24"/>
            </int32>
            <int32 name="total">
               <MinValue i="3"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="tap1">
               <MinValue i="0"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="tap2">
               <MinValue i="0"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="tap3">
               <MinValue i="0"/>
               <MaxValue i="16"/>
            </int32>
            <int32 name="tap4">
               <MinValue i="0"/>
               <MaxValue i="16"/>
            </int32>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[struct Settings
{
	int32_t bpm;
	int32_t division;
	int32_t totalTaps;
	int32_t tapPoints[4];
}settings = {110, 2, 8, {2,3,4,5}};

void saveDataBlock(FIL &file, const void *data, int size, char *filename)
{
    FRESULT err;
    UINT bytes_written;
    err = f_write(&file, data, size,&bytes_written);
    if (err != FR_OK) report_fatfs_error(err,filename);
}

void loadDataBlock(FIL &file, void *data, int size, char *filename)
{
    FRESULT err;
    UINT bytes_read;
    err = f_read(&file, data, size,&bytes_read);
    if (err != FR_OK) report_fatfs_error(err,filename);
}
void savePatch(int nr)
{
    char filename[128];
    chsnprintf(filename, sizeof(filename), "patch_rhythm_%03d.bin", nr); 
    LogTextMessage("saving to %s", filename);
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    codec_clearbuffer();
    err = f_open(&FileObject, filename, FA_WRITE | FA_CREATE_ALWAYS);
    if (err != FR_OK) {report_fatfs_error(err,filename); return;}
    saveDataBlock(FileObject, (void *)&settings, sizeof(settings),filename);
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,filename);
}

void loadPatch(int nr)
{
    char filename[128];
    chsnprintf(filename, sizeof(filename), "patch_rhythm_%03d.bin", nr); 
    LogTextMessage("saving to %s", filename);
    FIL FileObject;
    FRESULT err;
    UINT bytes_written;
    codec_clearbuffer();
    err = f_open(&FileObject, filename, FA_READ | FA_OPEN_EXISTING);
    if (err != FR_OK) {report_fatfs_error(err,filename); return;}
    loadDataBlock(FileObject,  (void *)&settings, sizeof(settings),filename);
    err = f_close(&FileObject);
    if (err != FR_OK) report_fatfs_error(err,filename);	
}]]></code.declaration>
         <code.krate><![CDATA[outlet_samplesTotal =  60*param_total*48000/param_bpm/param_div;
outlet_tap1 =  60*param_tap1*48000/param_bpm/param_div;
outlet_tap2 =  60*param_tap2*48000/param_bpm/param_div;
outlet_tap3 =  60*param_tap3*48000/param_bpm/param_div;
outlet_tap4 =  60*param_tap4*48000/param_bpm/param_div;

disp_d1 = outlet_samplesTotal;
disp_d2 = outlet_tap1;]]></code.krate>
      </object>
   </patchobj>
   <obj type="trisfreq" uuid="c9377000-383f-43c6-b11c-406b2ee95f2a" name="trisfreq_2" x="868" y="266">
      <params/>
      <attribs/>
   </obj>
   <obj type="adafruit_4x7segment" uuid="08314d3d-426d-4f8e-8320-487560daee8e" name="adafruit_4x7segment_1" x="224" y="364">
      <params/>
      <attribs/>
   </obj>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="770" y="378">
      <params>
         <frac32.u.map name="value" value="63.5"/>
      </params>
      <attribs/>
   </obj>
   <obj type="trisfreq" uuid="c9377000-383f-43c6-b11c-406b2ee95f2a" name="trisfreq_3" x="868" y="406">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="c4917c91-1609-4359-93f9-51665500b639" name="cc_1" x="14" y="504">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="c4917c91-1609-4359-93f9-51665500b639">
         <author>JS</author>
         <license>BSD</license>
         <helpPatch>midi_in.axh</helpPatch>
         <inlets/>
         <outlets>
            <int32 name="patchnr"/>
            <int32 name="prefix"/>
            <bool32 name="save"/>
            <bool32 name="load"/>
         </outlets>
         <displays>
            <int32.label name="patch"/>
         </displays>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int32_t patchNumber = 0;
int32_t ntrig = 0;
int32_t ntrigSave = 0;
int32_t ntrigLoad = 0;
int32_t mode = 'A';]]></code.declaration>
         <code.krate><![CDATA[outlet_patchnr = patchNumber;
outlet_prefix = mode;
outlet_save = ntrigSave;
disp_patch = patchNumber;
ntrigSave = 0;
outlet_load = ntrigLoad;
ntrigLoad = 0;]]></code.krate>
         <code.midihandler><![CDATA[LogTextMessage("%02x %d %d", status, data1, data2);

if ((status&0xF0) == MIDI_NOTE_ON) {

	if (data1 == 91) // play/pause
	{
		mode = 'L';
	     ntrigLoad = 1;
	}
	if (data1 == 93) // rec
	{
		mode = 'S';
	     ntrigSave = 1;
	}
 if (data1 == 64) 
 {
 	mode = 'P';
 	patchNumber--;
 	if (patchNumber < 0)
 		patchNumber = 99;
 }
 if (data1 == 65) 
 {
     mode = 'P';
 	patchNumber++;
 	if (patchNumber > 99)
 		patchNumber = 0;
 }
 if (data1 == 66) 
 {
     mode = 'P';
 	if (patchNumber % 10 == 0)
	 	patchNumber-=10;
     else
	 	patchNumber -= patchNumber % 10;
 	if (patchNumber < 0)
 		patchNumber = 99;
 }
 if (data1 == 67) 
 {
     mode = 'P';
	if (patchNumber % 10 == 0)
	 	patchNumber+=10;
     else
	 	patchNumber += 10-patchNumber % 10;
 	if (patchNumber > 99)
 		patchNumber = 0;
 }
}]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="trisfreq" uuid="c9377000-383f-43c6-b11c-406b2ee95f2a" name="trisfreq_4" x="868" y="546">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="66bfc0c0-4faf-401f-94e2-0ea73e1b17e4" name="==_1" x="196" y="630">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="66bfc0c0-4faf-401f-94e2-0ea73e1b17e4">
         <sDescription>test memsize</sDescription>
         <author>Johannes Taelman</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets/>
         <outlets/>
         <displays>
            <int32.label name="d1"/>
         </displays>
         <params/>
         <attribs/>
         <includes>
            <include>os/various/chprintf.h</include>
         </includes>
         <code.declaration><![CDATA[char lotsofData[100];]]></code.declaration>
         <code.init><![CDATA[lotsofData[0] = 0;
chsnprintf(lotsofData,100, "chsnprintf %4.3f %4d",123.45678f,-42);
LogTextMessage("'%s'", lotsofData);]]></code.init>
         <code.krate><![CDATA[disp_d1 = lotsofData[0];]]></code.krate>
         <code.midihandler><![CDATA[lotsofData[0] = status;]]></code.midihandler>
      </object>
   </patchobj>
   <obj type="gpio/i2c/config" uuid="b095a33e56de5fcd23740a7d983bc0bafb315d81" name="config_1" x="14" y="658">
      <params/>
      <attribs/>
   </obj>
   <nets>
      <net>
         <source obj="kticks2sec_1" outlet="samplesTotal"/>
         <dest obj="echo_1" inlet="delayTimeInSamples"/>
      </net>
      <net>
         <source obj="in_1" outlet="wave"/>
         <dest obj="mix_3" inlet="in1"/>
         <dest obj="gain_1" inlet="in"/>
      </net>
      <net>
         <source obj="mix_3" outlet="out"/>
         <dest obj="out_1" inlet="left"/>
         <dest obj="out_1" inlet="right"/>
      </net>
      <net>
         <source obj="kticks2sec_1" outlet="tap1"/>
         <dest obj="echo_1" inlet="tap1InSamples"/>
      </net>
      <net>
         <source obj="kticks2sec_1" outlet="tap2"/>
         <dest obj="echo_1" inlet="tap2InSamples"/>
      </net>
      <net>
         <source obj="kticks2sec_1" outlet="tap3"/>
         <dest obj="echo_1" inlet="tap3InSamples"/>
      </net>
      <net>
         <source obj="kticks2sec_1" outlet="tap4"/>
         <dest obj="echo_1" inlet="tap4InSamples"/>
      </net>
      <net>
         <source obj="digital_1" outlet="out"/>
         <dest obj="toggle_1" inlet="trig"/>
      </net>
      <net>
         <source obj="digital_2" outlet="out"/>
         <dest obj="toggle_2" inlet="trig"/>
      </net>
      <net>
         <source obj="toggle_1" outlet="o"/>
         <dest obj="led2_1" inlet="in"/>
         <dest obj="gain_1" inlet="onoff"/>
      </net>
      <net>
         <source obj="toggle_2" outlet="o"/>
         <dest obj="led1_1" inlet="in"/>
         <dest obj="echo_1" inlet="samplehold"/>
      </net>
      <net>
         <source obj="gain_1" outlet="out"/>
         <dest obj="mix_1" inlet="in1"/>
      </net>
      <net>
         <source obj="mix_1" outlet="out"/>
         <dest obj="echo_1" inlet="in"/>
      </net>
      <net>
         <source obj="echo_1" outlet="loopend"/>
         <dest obj="mix_1" inlet="in2"/>
      </net>
      <net>
         <source obj="lp1_1" outlet="out"/>
         <dest obj="mix_3" inlet="in2"/>
         <dest obj="mix_1" inlet="in3"/>
      </net>
      <net>
         <source obj="mix_2" outlet="out"/>
         <dest obj="lp1_1" inlet="in"/>
      </net>
      <net>
         <source obj="echo_1" outlet="tap0"/>
         <dest obj="trisfreq_1" inlet="audioin"/>
      </net>
      <net>
         <source obj="echo_1" outlet="tap1"/>
         <dest obj="trisfreq_2" inlet="audioin"/>
      </net>
      <net>
         <source obj="echo_1" outlet="tap2"/>
         <dest obj="trisfreq_3" inlet="audioin"/>
      </net>
      <net>
         <source obj="echo_1" outlet="tap3"/>
         <dest obj="trisfreq_4" inlet="audioin"/>
      </net>
      <net>
         <source obj="trisfreq_1" outlet="outlet_1"/>
         <dest obj="mix_2" inlet="in1"/>
      </net>
      <net>
         <source obj="midihandler" outlet="pitch1"/>
         <dest obj="trisfreq_1" inlet="pitch"/>
      </net>
      <net>
         <source obj="midihandler" outlet="pitch2"/>
         <dest obj="trisfreq_2" inlet="pitch"/>
      </net>
      <net>
         <source obj="trisfreq_2" outlet="outlet_1"/>
         <dest obj="mix_2" inlet="in2"/>
      </net>
      <net>
         <source obj="trisfreq_3" outlet="outlet_1"/>
         <dest obj="mix_2" inlet="in3"/>
      </net>
      <net>
         <source obj="trisfreq_4" outlet="outlet_1"/>
         <dest obj="mix_2" inlet="in4"/>
      </net>
      <net>
         <source obj="midihandler" outlet="combfdbk1"/>
         <dest obj="trisfreq_1" inlet="comb_feedback"/>
      </net>
      <net>
         <source obj="midihandler" outlet="comblevel1"/>
         <dest obj="trisfreq_1" inlet="comb_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="vcflevel1"/>
         <dest obj="trisfreq_1" inlet="wah_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="combfdbk2"/>
         <dest obj="trisfreq_2" inlet="comb_feedback"/>
      </net>
      <net>
         <source obj="midihandler" outlet="comblevel2"/>
         <dest obj="trisfreq_2" inlet="comb_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="ringlevel2"/>
         <dest obj="trisfreq_2" inlet="ring_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="vcflevel2"/>
         <dest obj="trisfreq_2" inlet="wah_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="pitch3"/>
         <dest obj="trisfreq_3" inlet="pitch"/>
      </net>
      <net>
         <source obj="midihandler" outlet="combfdbk3"/>
         <dest obj="trisfreq_3" inlet="comb_feedback"/>
      </net>
      <net>
         <source obj="midihandler" outlet="comblevel3"/>
         <dest obj="trisfreq_3" inlet="comb_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="ringlevel3"/>
         <dest obj="trisfreq_3" inlet="ring_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="vcflevel3"/>
         <dest obj="trisfreq_3" inlet="wah_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="pitch4"/>
         <dest obj="trisfreq_4" inlet="pitch"/>
      </net>
      <net>
         <source obj="midihandler" outlet="combfdbk4"/>
         <dest obj="trisfreq_4" inlet="comb_feedback"/>
      </net>
      <net>
         <source obj="midihandler" outlet="comblevel4"/>
         <dest obj="trisfreq_4" inlet="comb_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="ringlevel4"/>
         <dest obj="trisfreq_4" inlet="ring_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="vcflevel4"/>
         <dest obj="trisfreq_4" inlet="wah_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="ringlevel1"/>
         <dest obj="trisfreq_1" inlet="ring_gain"/>
      </net>
      <net>
         <source obj="midihandler" outlet="mix"/>
         <dest obj="mix_3" inlet="mix"/>
      </net>
      <net>
         <source obj="dial_1" outlet="out"/>
         <dest obj="trisfreq_1" inlet="wah_q"/>
         <dest obj="trisfreq_2" inlet="wah_q"/>
         <dest obj="trisfreq_3" inlet="wah_q"/>
         <dest obj="trisfreq_4" inlet="wah_q"/>
      </net>
      <net>
         <source obj="cc_1" outlet="patchnr"/>
         <dest obj="kticks2sec_1" inlet="patchnr"/>
         <dest obj="adafruit_4x7segment_1" inlet="intvalue"/>
         <dest obj="midihandler" inlet="patchnr"/>
      </net>
      <net>
         <source obj="cc_1" outlet="prefix"/>
         <dest obj="adafruit_4x7segment_1" inlet="prefix"/>
      </net>
      <net>
         <source obj="cc_1" outlet="save"/>
         <dest obj="kticks2sec_1" inlet="save"/>
         <dest obj="midihandler" inlet="save"/>
      </net>
      <net>
         <source obj="cc_1" outlet="load"/>
         <dest obj="kticks2sec_1" inlet="load"/>
         <dest obj="midihandler" inlet="load"/>
      </net>
      <net>
         <source obj="echo_1" outlet="db1"/>
         <dest obj="midihandler" inlet="level1"/>
      </net>
      <net>
         <source obj="echo_1" outlet="db2"/>
         <dest obj="midihandler" inlet="level2"/>
      </net>
      <net>
         <source obj="echo_1" outlet="db3"/>
         <dest obj="midihandler" inlet="level3"/>
      </net>
      <net>
         <source obj="echo_1" outlet="db4"/>
         <dest obj="midihandler" inlet="level4"/>
      </net>
      <net>
         <source obj="echo_1" outlet="dbIn"/>
         <dest obj="midihandler" inlet="levelmain"/>
      </net>
      <net>
         <source obj="echo_1" outlet="loopstart"/>
         <dest obj="adafruit_4x7segment_1" inlet="doubledot"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>1</MidiChannel>
      <NPresets>8</NPresets>
      <NPresetEntries>32</NPresetEntries>
      <NModulationSources>8</NModulationSources>
      <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
      <License>GPL</License>
   </settings>
   <notes><![CDATA[A 119
b 124
C 57
d 94
E 121
F 113
G 61
H 118
J 30
L 56
P 115
S 109
U 62
y 110
degree 99


]]></notes>
   <windowPos>
      <x>376</x>
      <y>23</y>
      <width>1064</width>
      <height>877</height>
   </windowPos>
</patch-1.0>